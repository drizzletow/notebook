import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,e}from"./app-CQ1Pqlzg.js";const t="/notebook/assets/image-20220227210559965-DdO3D9rR.png",o="/notebook/assets/image-20220227211314928-CZKxYesZ.png",p="/notebook/assets/image-20220227211924512-nfeFo-7r.png",l={},i=e(`<h1 id="jvm垃圾回收" tabindex="-1"><a class="header-anchor" href="#jvm垃圾回收"><span>Jvm垃圾回收</span></a></h1><h2 id="一-垃圾收集概述" tabindex="-1"><a class="header-anchor" href="#一-垃圾收集概述"><span>一 垃圾收集概述</span></a></h2><p>垃圾收集（Garbage Collection，下文简称GC）需要完成的三件事情：</p><ul><li>哪些内存需要回收？ 堆和方法区</li><li>什么时候回收？</li><li>如何回收？</li></ul><h3 id="_1-生存还是死亡" tabindex="-1"><a class="header-anchor" href="#_1-生存还是死亡"><span>1. 生存还是死亡</span></a></h3><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。</p><h4 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法"><span>引用计数法</span></a></h4><p>很多教科书判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p>客观地说，引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。</p><blockquote><p>也有一些比较著名的应用案例，例如微软COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言以及在游戏脚本领域得到许多应用的Squirrel中都使用了引用计数算法进行内存管理。</p></blockquote><p>但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p><blockquote><p>举个简单的例子：</p><ul><li>对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用</li><li>实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</li></ul></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGC</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token comment">// 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过</span>
    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bigSize <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ReferenceCountingGC</span> objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ReferenceCountingGC</span> objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>
        objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>

        objA <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        objB <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token comment">// 假设在这行发生GC，objA和objB是否能被回收？</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">[</span><span class="token class-name">Full</span> <span class="token constant">GC</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">Tenured</span><span class="token operator">:</span> <span class="token number">0</span>K<span class="token operator">-&gt;</span><span class="token function">210K</span><span class="token punctuation">(</span><span class="token number">10240</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0149142</span> secs<span class="token punctuation">]</span> <span class="token number">4603</span>K<span class="token operator">-&gt;</span><span class="token function">210K</span><span class="token punctuation">(</span><span class="token number">19456</span>K<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以清楚看到内存回收日志中包含“4603K-&gt;210K”，意味着虚拟机并没有因为这两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过引用计数算法来判断对象是否存活的。</p><h4 id="可达性分析" tabindex="-1"><a class="header-anchor" href="#可达性分析"><span>可达性分析</span></a></h4><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，</p><p>都是通过**可达性分析（Reachability Analysis）**算法来判定对象是否存活的。</p><blockquote><p>这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p></blockquote><p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p><blockquote><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。譬如后文将会提到的分代收集和局部回收（Partial GC），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。<br> 目前最新的几款垃圾收集器无一例外都具备了局部回收的特征，为了避免GC Roots包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。</p></blockquote><p><strong>对象的死亡</strong>：</p><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，<strong>要真正宣告一个对象死亡，至少要经历两次标记过程</strong>：</p><ul><li><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记</p></li><li><p>随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法</p><ul><li>假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</li><li>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</li></ul><blockquote><p>这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。</p><p>这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。</p><p><strong>finalize()方法是对象逃脱死亡命运的最后一次机会</strong>，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；</p><p>如果对象这时候还没有逃脱，那基本上它就真的要被回收了</p></blockquote></li></ul><p>【注】建议尽量避免使用 <code>finalize()</code> 方法，因为它并不能等同于C和C++语言中的析构函数，而是Java刚诞生时为了使传统C、C++程序员更容易接受Java所做出的一项妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言里面的这个方法。</p><h3 id="_2-引用的分类" tabindex="-1"><a class="header-anchor" href="#_2-引用的分类"><span>2. 引用的分类</span></a></h3><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ul><li><p><strong>强引用</strong>：是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 <code>Object obj=new Object()</code> 这种引用关系</p><p>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p></li><li><p><strong>软引用</strong>：是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</p></li><li><p><strong>弱引用</strong>：也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p></li><li><p><strong>虚引用</strong>：也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p></li></ul><p>为什么要将引用分类呢？</p><blockquote><p>在JDK 1.2版之前，Java里面的引用是很传统的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应用场景。</p></blockquote><h3 id="_3-回收方法区" tabindex="-1"><a class="header-anchor" href="#_3-回收方法区"><span>3. 回收方法区</span></a></h3><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）</p><p>方法区垃圾收集的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p><p>方法区的垃圾收集主要回收两部分内容：<strong>废弃的常量和不再使用的类型</strong>。</p><blockquote><p>回收废弃常量与回收Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，但仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p></blockquote><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><h2 id="二-垃圾收集算法" tabindex="-1"><a class="header-anchor" href="#二-垃圾收集算法"><span>二 垃圾收集算法</span></a></h2><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为：（主流Java虚拟机中均未涉及引用计数式垃圾收集算法）</p><ul><li>“引用计数式垃圾收集”（Reference Counting GC）， 也叫直接垃圾收集</li><li><strong>“追踪式垃圾收集”（Tracing GC）</strong>， 也叫“间接垃圾收集” ，主流算法</li></ul><h3 id="_1-分代收集理论" tabindex="-1"><a class="header-anchor" href="#_1-分代收集理论"><span>1. 分代收集理论</span></a></h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了 **“分代收集”（Generational Collection）**的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p><ul><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ul><p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</p><blockquote><p>显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p></blockquote><p>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了<code>“Minor GC” “Major GC” “Full GC”</code> 这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算法”“标记-整理算法”等针对性的垃圾收集算法。</p><br><ul><li><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</p><ul><li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，需按上下文区分到底是指老年代的收集还是整堆收集。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li></ul></li><li><p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p></li></ul><h3 id="_2-标记-清除算法" tabindex="-1"><a class="header-anchor" href="#_2-标记-清除算法"><span>2. 标记-清除算法</span></a></h3><p>标记-清除（Mark-Sweep）算法 ：分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。</p><figure><img src="`+t+'" alt="image-20220227210559965" tabindex="0" loading="lazy"><figcaption>image-20220227210559965</figcaption></figure><blockquote><p>之所以说它是最基础的收集算法，是因为后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。</p><p>它的主要缺点有两个：</p><ul><li>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul></blockquote><h3 id="_3-标记-复制算法" tabindex="-1"><a class="header-anchor" href="#_3-标记-复制算法"><span>3. 标记-复制算法</span></a></h3><p>标记-复制算法常被简称为复制算法。现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代</p><blockquote><p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p></blockquote><figure><img src="'+o+'" alt="image-20220227211314928" tabindex="0" loading="lazy"><figcaption>image-20220227211314928</figcaption></figure><p>IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。</p><blockquote><p>在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的<strong>半区复制分代策略</strong>，现在称为“<strong>Appel式回收</strong>”。</p><p>HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。</p><ul><li><p>Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。</p></li><li><p>当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p></li></ul></blockquote><h3 id="_4-标记-整理算法" tabindex="-1"><a class="header-anchor" href="#_4-标记-整理算法"><span>4. 标记-整理算法</span></a></h3><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的**“标记-整理”（Mark-Compact）算法**，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图：</p><figure><img src="'+p+'" alt="image-20220227211924512" tabindex="0" loading="lazy"><figcaption>image-20220227211924512</figcaption></figure><p>标记-清除算法 与 标记-整理算法 的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。</p><blockquote><p>是否移动回收后的存活对象是一项优缺点并存的风险决策：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World”。</p><p>但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。</p><p>内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。</p><p>基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。</p><p>此语境中，吞吐量的实质是赋值器（Mutator，可以理解为使用垃圾收集的用户程序，本书为便于理解，多数地方用“用户程序”或“用户线程”代替）与收集器的效率总和。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。</p><p>另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</p><p>前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。</p></blockquote><h2 id="三-hotspot算法细节" tabindex="-1"><a class="header-anchor" href="#三-hotspot算法细节"><span>三 Hotspot算法细节</span></a></h2><h3 id="_1-根节点枚举" tabindex="-1"><a class="header-anchor" href="#_1-根节点枚举"><span>1. 根节点枚举</span></a></h3>',65),c=[i];function r(u,d){return n(),s("div",null,c)}const m=a(l,[["render",r],["__file","gc.html.vue"]]),h=JSON.parse('{"path":"/java/syntax/jvm/gc.html","title":"Jvm垃圾回收","lang":"en-US","frontmatter":{"order":20,"description":"Jvm垃圾回收 一 垃圾收集概述 垃圾收集（Garbage Collection，下文简称GC）需要完成的三件事情： 哪些内存需要回收？ 堆和方法区 什么时候回收？ 如何回收？ 1. 生存还是死亡 在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不...","head":[["meta",{"property":"og:url","content":"https://x.app/notebook/java/syntax/jvm/gc.html"}],["meta",{"property":"og:site_name","content":"Notebook"}],["meta",{"property":"og:title","content":"Jvm垃圾回收"}],["meta",{"property":"og:description","content":"Jvm垃圾回收 一 垃圾收集概述 垃圾收集（Garbage Collection，下文简称GC）需要完成的三件事情： 哪些内存需要回收？ 堆和方法区 什么时候回收？ 如何回收？ 1. 生存还是死亡 在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-04-15T09:06:58.000Z"}],["meta",{"property":"article:author","content":"Mr.Topple"}],["meta",{"property":"article:modified_time","content":"2024-04-15T09:06:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Jvm垃圾回收\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-15T09:06:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Topple\\",\\"url\\":\\"https://www.baidu.com\\"}]}"]]},"headers":[{"level":2,"title":"一 垃圾收集概述","slug":"一-垃圾收集概述","link":"#一-垃圾收集概述","children":[{"level":3,"title":"1. 生存还是死亡","slug":"_1-生存还是死亡","link":"#_1-生存还是死亡","children":[]},{"level":3,"title":"2. 引用的分类","slug":"_2-引用的分类","link":"#_2-引用的分类","children":[]},{"level":3,"title":"3. 回收方法区","slug":"_3-回收方法区","link":"#_3-回收方法区","children":[]}]},{"level":2,"title":"二 垃圾收集算法","slug":"二-垃圾收集算法","link":"#二-垃圾收集算法","children":[{"level":3,"title":"1. 分代收集理论","slug":"_1-分代收集理论","link":"#_1-分代收集理论","children":[]},{"level":3,"title":"2. 标记-清除算法","slug":"_2-标记-清除算法","link":"#_2-标记-清除算法","children":[]},{"level":3,"title":"3. 标记-复制算法","slug":"_3-标记-复制算法","link":"#_3-标记-复制算法","children":[]},{"level":3,"title":"4. 标记-整理算法","slug":"_4-标记-整理算法","link":"#_4-标记-整理算法","children":[]}]},{"level":2,"title":"三 Hotspot算法细节","slug":"三-hotspot算法细节","link":"#三-hotspot算法细节","children":[{"level":3,"title":"1. 根节点枚举","slug":"_1-根节点枚举","link":"#_1-根节点枚举","children":[]}]}],"git":{"createdTime":1713172018000,"updatedTime":1713172018000,"contributors":[{"name":"Neil","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":22.17,"words":6651},"filePathRelative":"java/syntax/jvm/gc.md","localizedDate":"April 15, 2024","autoDesc":true}');export{m as comp,h as data};
