import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as t}from"./app-B05z7mYU.js";const e={},p=t(`<h2 id="aqs抽象队列同步器" tabindex="-1"><a class="header-anchor" href="#aqs抽象队列同步器"><span>AQS抽象队列同步器</span></a></h2><p>AQS（AbstractQueuedSynchronizer，抽象队列同步器）是Java并发包（<code>java.util.concurrent.locks</code>）中的一个核心组件，由Doug Lea设计，旨在为实现锁和其他同步组件（如信号量、屏障等）提供基础框架。AQS简化了自定义同步组件的开发过程，通过封装复杂的同步逻辑，如线程的阻塞、唤醒、同步状态管理等。</p><ol><li><strong>同步状态管理</strong>：AQS提供了一个整型的同步状态（<code>state</code>）变量，用于表示资源是否被占用的状态。</li><li><strong>线程阻塞与唤醒</strong>：通过维护一个FIFO的双向链表（CLH队列），管理等待获取锁的线程。当线程尝试获取锁失败时，会被加入到这个队列中并进入等待状态，直到被唤醒。</li><li><strong>公平与非公平策略</strong>：支持公平锁和非公平锁的实现，公平策略按照线程等待的顺序分配锁，而非公平策略允许插队，提高吞吐量。</li><li><strong>灵活的同步模式</strong>：既支持独占式（如ReentrantLock）也支持共享式（如Semaphore、CountDownLatch）的同步。</li></ol><div class="hint-container tip"><p class="hint-container-title">AQS内部原理解析</p><ul><li><strong>同步状态管理</strong>：使用<code>volatile</code>关键字保证状态可见性，通过CAS（Compare and Swap）操作实现状态的无锁原子更新。</li><li><strong>队列管理</strong>：内部维护一个双向链表（Node），每个Node代表一个等待的线程。Node包含前驱和后继指针，以及线程状态等信息。</li><li><strong>等待与唤醒机制</strong>：基于LockSupport工具类，通过park()和unpark()方法实现线程的阻塞与唤醒。</li><li><strong>模板方法设计模式</strong>：AQS定义了一系列protected方法，子类通过重写这些方法来实现特定的同步逻辑。</li></ul></div><p>使用AQS通常意味着你需要创建一个它的子类，并重写一些关键方法。以下是一个简化的AQS子类示例，实现一个简单的自旋锁：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySpinLock</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>底层使用到AQS的并发工具</strong>:</p><ul><li><code>ReentrantLock</code>：可重入独占锁。</li><li><code>ReentrantReadWriteLock</code>：读写锁，支持更细粒度的并发控制。</li><li><code>CountDownLatch</code>：允许一个或多个线程等待其他线程完成操作。</li><li><code>CyclicBarrier</code>：让一组线程等待所有线程到达某个屏障后再一起执行。</li><li><code>Semaphore</code>：控制同时访问特定资源的线程数。</li><li><code>FutureTask</code> 和 <code>Phaser</code> 等其他高级同步组件。</li></ul><p><strong>实际开发中需要使用AQS吗?</strong><br> 在实际开发中，直接使用AQS的机会较少，因为Java并发包已经提供了很多基于AQS实现的高级同步工具。开发者通常会直接使用如<code>ReentrantLock</code>、<code>Semaphore</code>等现成的同步工具。但是，如果你需要实现自定义的同步逻辑，或者现有的工具无法满足特定需求时，深入理解和使用AQS来构建自定义同步组件是非常有价值的。AQS提供了一个强大的框架，使得编写高性能、可靠的并发代码变得更加容易。</p><h2 id="semaphore" tabindex="-1"><a class="header-anchor" href="#semaphore"><span>Semaphore</span></a></h2><p>信号量（Semaphore）是并发编程中一种用于控制多个线程访问共享资源的同步工具。它维护了一个许可集，线程可以通过获取许可来访问资源，执行完毕后释放许可，使得其他线程有机会访问。信号量可以用来限制同时访问特定资源的线程数，或者用来实现某些线程间的同步。</p><h3 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数"><span>构造函数</span></a></h3><p>在Java中，<code>Semaphore</code>提供了两种主要的构造方式，用于初始化信号量的许可数量以及（在某些情况下）是否公平策略：</p><div class="hint-container info"><p class="hint-container-title">Semaphore的创建方式</p><h4 id="_1-无公平性参数的构造函数" tabindex="-1"><a class="header-anchor" href="#_1-无公平性参数的构造函数"><span>1. 无公平性参数的构造函数</span></a></h4><ul><li><strong>非公平模式</strong>（默认）：在这种模式下，线程获取许可的操作相对更快，因为不保证按照线程等待的顺序分配许可。这可能导致某些线程频繁获取许可，而其他线程长时间等待。适用于对吞吐量有较高要求，且对线程调度公平性要求不高的场景。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">permits</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><strong>permits</strong>: 这是Semaphore初始化时的许可数量。它表示同一时刻可以有多少个线程同时持有该信号量的许可并执行受保护的代码段。如果<code>permits</code>设置为1，那么Semaphore表现得就像一个二进制信号量，即一次只允许一个线程通过。</li></ul><h4 id="_2-含有公平性参数的构造函数" tabindex="-1"><a class="header-anchor" href="#_2-含有公平性参数的构造函数"><span>2. 含有公平性参数的构造函数</span></a></h4><ul><li><strong>公平模式</strong>：在这种模式下，线程按照它们请求许可的顺序来获取许可，等待时间最长的线程将优先获得许可。这可以避免饥饿现象，但可能会因为维持线程等待顺序的额外开销而降低整体性能。适用于对线程调度公平性要求较高的场景，即使是以牺牲一定的吞吐量为代价</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">permits</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><strong>permits</strong>: 同上，表示初始的许可数量。</li><li><strong>fair</strong>: 这是一个布尔值参数，用于指明是否启用公平策略。如果设置为<code>true</code>，则等待时间最长的线程会优先获得许可（公平模式）。如果为<code>false</code>（默认），则不保证等待最久的线程一定能先获取许可，这可能会导致某些线程饥饿（非公平模式）。公平策略会降低吞吐量，因为它需要额外的同步开销来维护线程的等待顺序。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建一个非公平的Semaphore，初始许可数为3</span>
<span class="token class-name">Semaphore</span> nonFairSemaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建一个公平的Semaphore，初始许可数为3，等待线程按照FIFO顺序获取许可</span>
<span class="token class-name">Semaphore</span> fairSemaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h3 id="常用方法" tabindex="-1"><a class="header-anchor" href="#常用方法"><span>常用方法</span></a></h3><p>在Java中，信号量由<code>java.util.concurrent.Semaphore</code>类表示，主要方法包括：</p><ul><li><strong>acquire()</strong>：尝试获取一个许可，如果当前没有可用许可，则线程将被阻塞，直到其他线程释放许可。</li><li><strong>tryAcquire()</strong>：尝试获取一个许可，如果当前没有可用许可，立即返回<code>false</code>，不会阻塞线程。</li><li><strong>release()</strong>：释放一个许可，增加信号量的许可数，可能唤醒一个正在阻塞的线程。</li><li><strong>availablePermits()</strong>：返回当前可用的许可数。</li></ul><h3 id="使用场景及示例" tabindex="-1"><a class="header-anchor" href="#使用场景及示例"><span>使用场景及示例</span></a></h3><div class="hint-container tip"><p class="hint-container-title">使用场景</p><ul><li><strong>资源计数</strong>：控制同时访问数据库连接数、文件句柄数等有限资源。</li><li><strong>池化技术</strong>：管理线程池、连接池等，限制同时运行的任务数。</li><li><strong>同步屏障</strong>：可以作为一种灵活的同步机制，实现类似于CyclicBarrier的功能。</li></ul></div><p><strong>使用流程</strong>:</p><ol><li><strong>初始化信号量</strong>：创建一个<code>Semaphore</code>对象，指定初始的许可数量。</li><li><strong>获取许可</strong>：在需要访问资源的线程中调用<code>acquire()</code>方法获取许可，如果没有许可可获取则阻塞。</li><li><strong>访问资源</strong>：获得许可的线程可以安全地访问共享资源。</li><li><strong>释放许可</strong>：访问完资源后，调用<code>release()</code>方法释放许可，使得其他等待的线程可以继续。</li></ol><p>假设我们有一个场景，需要限制同时访问数据库的线程数不超过5个。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Semaphore</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreExample</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">THREAD_COUNT</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最多允许5个线程同时运行</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token constant">THREAD_COUNT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">THREAD_COUNT</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取许可</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; is accessing database.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟数据库访问操作</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; finished.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; interrupted.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放许可</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了一个最多允许5个线程同时访问数据库的信号量。20个线程尝试访问数据库，但每次只有5个线程能够获得许可并执行，其余线程将等待，直到有线程释放许可。这样就有效地控制了并发访问的数量，避免了资源的过度竞争。</p><h3 id="底层实现原理" tabindex="-1"><a class="header-anchor" href="#底层实现原理"><span>底层实现原理</span></a></h3><p>Semaphore的底层实现原理基于Java并发包中的<code>AbstractQueuedSynchronizer</code>（AQS）框架。AQS是一个抽象类，它为实现依赖于先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量、栅栏等）提供了一个框架。Semaphore利用了AQS的底层机制来管理一个许可集（permits）和一个线程等待队列。</p><p><strong>核心组件</strong>：</p><ol><li><p><strong>State</strong>: AQS内部维护一个整型变量<code>state</code>，在Semaphore中，这个变量表示当前可用的许可数。初始化Semaphore时，<code>state</code>会被设置为传入的许可数。</p></li><li><p><strong>acquire()和release()</strong>: Semaphore通过重写AQS的<code>tryAcquireShared()</code>和<code>tryReleaseShared()</code>方法来实现<code>acquire()</code>和<code>release()</code>操作。如下：</p><ul><li><p><strong>acquire()</strong>: 实际上是调用AQS的<code>acquireSharedInterruptibly()</code>方法，尝试从Semaphore获取一个许可，如果当前<code>state</code>（即许可数）大于0，那么<code>state</code>减1，并且线程获得许可；如果许可不足，线程则被构造为Node节点加入到AQS的等待队列中，并进入等待状态。</p></li><li><p><strong>release()</strong>: 对应的是AQS的<code>releaseShared()</code>方法，它会增加许可数（<code>state</code>），并唤醒等待队列中的一个或多个线程（如果有线程在等待）。</p></li></ul></li><li><p><strong>等待队列</strong>: AQS维护了一个双向链表作为线程的等待队列。当线程因无法获取许可而需要等待时，它会被构造成Node节点并插入队列。这个队列是FIFO的，保证了线程的公平性（如果Semaphore被配置为公平模式的话）。</p></li><li><p><strong>同步状态</strong>: AQS还通过内置的锁机制来保护<code>state</code>变量的修改，确保多线程环境下的操作是线程安全的。</p></li></ol><p><strong>公平与非公平策略</strong>：</p><ul><li><p><strong>公平模式</strong>: 如果Semaphore被设置为公平模式，那么线程在尝试获取许可时会检查是否有比自己更早到达的线程已经在等待。如果有，新来的线程就会排队等待，保证先到的线程优先获取许可。</p></li><li><p><strong>非公平模式</strong>: 非公平模式下，新来的线程在尝试获取许可时可能会直接获取，即使有其他线程已经在等待。这种模式下，尽管牺牲了一定的公平性，但通常能提高吞吐量。</p></li></ul><h2 id="cyclicbarrier" tabindex="-1"><a class="header-anchor" href="#cyclicbarrier"><span>CyclicBarrier</span></a></h2><p><code>CyclicBarrier</code>是Java并发编程中一个同步工具类，它允许一组线程相互等待，直到所有线程都到达一个共同的屏障点（barrier point），然后所有线程一起继续执行。这个名字“Cyclic”意味着这个屏障可以被重置并重复使用多次，而不仅仅是一次性使用。它在多线程协作的场景中特别有用，比如在并行计算中，当需要等待所有任务完成后再进行下一步操作时。</p><h3 id="构造函数-1" tabindex="-1"><a class="header-anchor" href="#构造函数-1"><span>构造函数</span></a></h3><p>CyclicBarrier有几种构造方法，主要的构造方法如下：</p><ul><li><code>CyclicBarrier(int parties)</code>：创建一个新的 CyclicBarrier，它将在给定数量的参与线程到达屏障时启动，不带额外的Runnable操作。</li><li><code>CyclicBarrier(int parties, Runnable barrierAction)</code>：创建一个新的 CyclicBarrier，它将在给定数量的参与线程到达屏障时启动，并在每次屏障动作完成后执行给定的Runnable操作。这个Runnable会在所有线程到达屏障之后，但在释放它们之前执行，可以用于初始化下一个阶段的工作。</li></ul><div class="hint-container tip"><p class="hint-container-title">构造函数参数</p><ul><li><code>parties</code>：表示需要同步的线程数量，即屏障需要等待的线程总数。</li><li><code>count</code>：初始化时等于<code>parties</code>，每当一个线程调用<code>await()</code>方法时，<code>count</code>减1，当<code>count</code>减至0时，所有等待的线程被释放。</li></ul></div><h3 id="常用方法-1" tabindex="-1"><a class="header-anchor" href="#常用方法-1"><span>常用方法</span></a></h3><ul><li><code>await()</code>：线程调用此方法告诉CyclicBarrier它已经到达屏障。<div class="hint-container info"><p class="hint-container-title">await()方法详解</p><ul><li>当线程调用<code>await()</code>时，它首先会获取<code>lock</code>，然后将<code>count</code>减1。</li><li>如果<code>count</code>减至0，表示所有线程已到达屏障，这时： <ul><li>如果设置了<code>barrierAction</code>（构造函数中的Runnable），则先执行这个动作。</li><li>唤醒所有等待在<code>condition</code>上的线程，然后重置<code>count</code>为<code>parties</code>，准备下一轮等待。</li></ul></li><li>如果<code>count</code>不为0，表示还有线程未到达，当前线程则在<code>condition</code>上等待。</li></ul></div></li><li><code>reset()</code>：重置屏障，将<code>count</code>恢复到初始值<code>parties</code>，<code>generation</code>的值会递增，如果线程当前正阻塞在<code>await()</code>上，则它们将收到<code>BrokenBarrierException</code>异常并退出阻塞。</li><li><code>getNumberWaiting()</code>：返回当前在屏障上等待的线程数量。</li><li><code>isBroken()</code>：查询屏障是否损坏，即是否有线程在等待时被中断或超时。</li></ul><h3 id="使用场景及示例-1" tabindex="-1"><a class="header-anchor" href="#使用场景及示例-1"><span>使用场景及示例</span></a></h3><p><strong>使用场景</strong></p><ol><li><strong>分布式计算中的数据聚合</strong>：在分布式系统中，可以使用CyclicBarrier来确保所有节点的数据处理完成后再进行数据汇总。</li><li><strong>并行任务的阶段划分</strong>：当一个任务可以分解为多个子任务并行执行时，可以在每个子任务完成之后使用CyclicBarrier等待所有子任务完成，然后进行下一阶段的操作。</li><li><strong>游戏中的同步</strong>：在网络游戏中，可以用来同步玩家的动作，确保所有玩家都准备好后才开始新的一轮游戏。</li></ol><p>假设需要并行处理一个大文件的不同部分，然后合并处理结果。我们可以使用CyclicBarrier来确保所有部分都处理完毕后再进行结果合并：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">BrokenBarrierException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CyclicBarrier</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileProcessor</span> <span class="token punctuation">{</span>

    <span class="token comment">// 假设我们要处理的文件被切分为4个部分</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">PARTITIONS</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">CyclicBarrier</span> barrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token constant">PARTITIONS</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 所有分区处理完毕，这里是合并结果的逻辑</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;所有分区处理完成，开始合并结果...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">PARTITIONS</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> partitionId <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">processPartition</span><span class="token punctuation">(</span>partitionId<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">processPartition</span><span class="token punctuation">(</span><span class="token keyword">int</span> partitionId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 模拟处理文件分区的逻辑</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程 &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 开始处理分区 &quot;</span> <span class="token operator">+</span> partitionId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟处理时间</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程 &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 完成处理分区 &quot;</span> <span class="token operator">+</span> partitionId<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理完成后等待其他线程</span>
            barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个CyclicBarrier，参数为4，意味着我们需要等待4个线程（对应文件的4个分区）全部完成处理。当所有线程都调用了<code>barrier.await()</code>后，屏障打开，执行我们定义的Runnable，这里是合并处理结果的逻辑。每个线程代表处理文件的一个分区，处理完自己的分区后调用<code>await()</code>等待，直到所有线程都完成，然后合并结果的操作被执行。这样就确保了文件的所有分区被并行高效处理，并且只有当所有分区都处理完毕后才会进行结果的合并。</p><div class="hint-container tip"><p class="hint-container-title">注意事项</p><ul><li>当线程在等待过程中被中断，或者屏障被<code>reset()</code>方法重置，<code>count</code>不会归零，<code>generation</code>会递增，同时抛出<code>BrokenBarrierException</code>异常，告知等待线程屏障已损坏。</li><li>如果某个线程在等待时超时（尽管CyclicBarrier本身不直接支持超时），那么它也会导致屏障被破坏。</li><li>使用CyclicBarrier时，要考虑异常处理，特别是在Runnable中，确保异常不会导致整个协作进程失败。</li></ul></div><h3 id="底层实现原理-1" tabindex="-1"><a class="header-anchor" href="#底层实现原理-1"><span>底层实现原理</span></a></h3><p>CyclicBarrier的底层实现主要依赖于Java并发包中的AbstractQueuedSynchronizer（AQS）框架，以及<code>ReentrantLock</code>和<code>Condition</code>对象来进行线程间的同步和等待通知机制。</p><p>在<code>CyclicBarrier</code>类中，<code>generation</code>、<code>lock</code>和<code>condition</code>是几个关键的内部组件，它们共同协作以实现CyclicBarrier的同步功能:</p><ol><li><p><strong>lock</strong>: 这是一个<code>ReentrantLock</code>对象，用于在多线程环境下保护CyclicBarrier内部状态的修改，确保状态变更的原子性和线程安全性。当线程调用<code>await()</code>方法时，首先会尝试获取这个锁，从而确保对计数器（<code>count</code>）和其他状态的修改不会发生冲突。</p></li><li><p><strong>condition</strong>: 与<code>lock</code>关联的一个<code>Condition</code>对象，用于在线程需要等待时挂起线程，直到被其他线程唤醒。当调用<code>await()</code>的线程发现还有其他线程未到达屏障时，它会在这个<code>condition</code>上等待，直到被释放。</p></li><li><p><strong>generation</strong>: 这是一个整数型变量，用来跟踪CyclicBarrier的使用周期。每次CyclicBarrier成功完成一次所有线程的汇聚（即所有线程到达屏障并继续执行），或者当屏障被破坏（例如，有线程中断或超时导致<code>BrokenBarrierException</code>被抛出），<code>generation</code>的值会递增。它是一个关键的机制，用于区分不同轮次的等待周期，确保线程不会错误地从上一轮的等待中醒来。</p></li></ol><h2 id="countdownlatch" tabindex="-1"><a class="header-anchor" href="#countdownlatch"><span>CountDownLatch</span></a></h2><p><code>CountDownLatch</code>允许一个或多个线程等待其他线程完成一系列操作后再继续执行。这是一个典型的同步辅助类，常用于主线程需要等待多个子线程完成后再进行下一步操作的场景。</p><p><code>CountDownLatch</code>只有一个构造函数：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>count</code>: 整型参数，表示需要等待的计数次数。初始化时设置的计数值，每当调用<code>countDown()</code>方法，这个值就减1，直到减至0时，所有在<code>await()</code>方法上等待的线程会被释放。</li></ul><p><strong>常用方法</strong>：</p><ul><li><p><strong>countDown()</strong>: 减少计数器的值。每次调用此方法，内部计数器<code>count</code>减1。</p></li><li><p><strong>await()</strong>: 使当前线程等待，直到计数器的值变为零，然后继续执行。<br><code>await(long timeout, TimeUnit unit)</code>允许等待指定的时间后超时返回。</p></li><li><p><strong>getCount()</strong>： 返回当前计数器的值。</p></li></ul><p>代码示例：假设有一个应用程序启动时需要完成多个初始化任务，主程序需要等待所有初始化任务完成后才能继续运行。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 初始化计数器，假设我们有3个初始化任务</span>
        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 提交任务到线程池</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token keyword">int</span> taskId <span class="token operator">=</span> i<span class="token punctuation">;</span>
            executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">doTask</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 每个任务完成后，计数器减1</span>
                latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 主线程等待所有任务完成</span>
        latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;所有初始化任务已完成，主程序继续执行...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> taskId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;任务 &quot;</span> <span class="token operator">+</span> taskId <span class="token operator">+</span> <span class="token string">&quot; 开始执行...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;任务 &quot;</span> <span class="token operator">+</span> taskId <span class="token operator">+</span> <span class="token string">&quot; 执行结束.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">CountDownLatch底层实现原理</p><p><code>CountDownLatch</code>的底层实现同样基于<code>AbstractQueuedSynchronizer</code>（AQS）。它通过维护一个内部状态（state）来记录剩余的计数。<code>countDown()</code>方法调用会减少这个状态值，而<code>await()</code>方法会让调用它的线程阻塞，直到状态值变为0。当状态值为0时，所有在<code>await()</code>上阻塞的线程会被唤醒。</p><p>与<code>Semaphore</code>和<code>CyclicBarrier</code>不同，<code>CountDownLatch</code>是一次性的，一旦计数到达零，就不能再重置，也无法再次使用。这是它与<code>CyclicBarrier</code>的主要区别之一，后者是可重置的同步屏障。</p></div><h2 id="completablefuture" tabindex="-1"><a class="header-anchor" href="#completablefuture"><span>CompletableFuture</span></a></h2><p><code>CompletableFuture</code> 是 Java 8 引入的一个非常强大的异步编程工具，它是 <code>Future</code> 接口的一个扩展，不仅支持异步执行任务，还提供了丰富的组合能力，如链式调用、转换、组合多个异步操作等，使得异步编程更加灵活和高效。</p><div class="hint-container tip"><p class="hint-container-title">为什么需要CompletableFuture</p><p>CompletableFuture是对Future的改进</p><ul><li>get()方法在Future计算完成之前会一直处在阻塞状态下，阻塞的方式和异步编程的设计理念相违背。</li><li>isDone()方法容易耗费cpu资源（cpu空转）</li></ul><p>对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果</p></div><h3 id="特性及原理" tabindex="-1"><a class="header-anchor" href="#特性及原理"><span>特性及原理</span></a></h3><ol><li><p><strong>观察者模式</strong>：<code>CompletableFuture</code> 内部使用了观察者模式，通过一个链表结构（<code>Completion</code> 链表）来存储一系列待执行的任务（即观察者）。当一个任务完成时，它会触发链表中的下一个任务开始执行。</p></li><li><p><strong>非阻塞机制</strong>：与传统的 <code>Future</code> 不同，<code>CompletableFuture</code> 提供了非阻塞的 API，如 <code>thenApply</code>, <code>thenAccept</code>, <code>thenCompose</code> 等，这些方法可以在前一个阶段完成后自动执行后续操作，而不需要显式地调用阻塞方法如 <code>get()</code>。</p></li><li><p><strong>任务调度</strong>：<code>CompletableFuture</code> 支持自定义执行器（Executor），允许用户指定任务在哪个线程池中执行，从而更好地控制并发策略和资源分配。</p></li><li><p><strong>状态管理</strong>：它内部维护了任务的状态，包括 <code>NEW</code>（新建）、<code>COMPLETING</code>（完成中）、<code>NORMAL</code>（正常完成）、<code>EXCEPTIONAL</code>（异常完成）等，使用 CAS（Compare and Swap）操作保证状态变更的原子性。</p></li></ol><div class="hint-container tip"><p class="hint-container-title">底层原理浅析</p><ul><li><strong>栈结构</strong>：内部维护了一个栈结构来存储待执行的函数，这些函数会在前序任务完成后按顺序执行。</li><li><strong>线程池</strong>：默认情况下，<code>CompletableFuture</code> 使用 <code>ForkJoinPool.commonPool()</code> 作为执行器，用户也可以指定自定义的线程池。</li><li><strong>非阻塞同步</strong>：利用了 <code>LockSupport.park/unpark</code> 和 CAS 操作实现高效的线程同步，减少不必要的阻塞等待。</li></ul></div><p><code>CompletableFuture</code> 提供了一种灵活、高效的异步编程模型，非常适合构建响应式、高性能的应用程序。</p><h3 id="创建方式" tabindex="-1"><a class="header-anchor" href="#创建方式"><span>创建方式</span></a></h3><p><strong>如何创建CompletableFuture</strong></p><ol><li><p><strong>静态方法创建</strong></p><ul><li><p><code>CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</code>：异步执行给定的Runnable任务，没有返回值。</p></li><li><p><code>CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</code> :<br> Executor表示执行异步任务的线程池或执行器</p></li><li><p><code>CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</code>：异步执行Supplier提供的任务并返回一个结果。</p></li><li><p><code>CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code></p></li></ul><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>异步任务在 <code>CompletableFuture.supplyAsync</code> 等方法被调用后立即启动执行</p></div></li><li><p><strong>直接创建实例</strong></p><ul><li>虽然可以通过构造函数创建一个已完成或异常的 CompletableFuture，但更常见的是使用上面的静态方法。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><div class="hint-container info"><p class="hint-container-title">CompletableFuture和线程池说明</p><ol><li><p><strong>默认线程池</strong>：</p><ul><li>如果在创建<code>CompletableFuture</code>时不提供特定的<code>Executor</code>(线程池)，那么对于大多数<code>async</code>方法（如<code>supplyAsync(Supplier&lt;U&gt; supplier)</code>或<code>runAsync(Runnable runnable)</code>），<code>CompletableFuture</code>会默认使用<code>ForkJoinPool.commonPool()</code>作为执行异步任务的线程池。这个线程池是Java Fork/Join框架的一部分，适用于那些可以被分解为更小任务的并行计算场景。</li></ul></li><li><p><strong>自定义线程池</strong>：</p><ul><li>你可以通过向<code>async</code>方法提供一个<code>Executor</code>参数来自定义线程池。例如，<code>supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code>或<code>runAsync(Runnable runnable, Executor executor)</code>。这样，你就可以根据应用需求配置线程池的大小、队列策略等，以达到最优的资源利用和性能。</li></ul></li><li><p><strong>方法与线程池的关系</strong>：</p><ul><li><p><code>thenApply</code>, <code>thenAccept</code>, <code>thenRun</code>, <code>thenCompose</code>, <code>thenCombine</code>, <code>thenAcceptBoth</code>, <code>applyToEither</code>, <code>acceptEither</code>, <code>runAfterEither</code>等方法，它们是在前一个阶段完成后的继续处理步骤，通常不会直接关联到特定的线程池，而是沿用之前阶段使用的线程池。如果前一阶段使用的是默认线程池，那么这些方法也会使用相同的线程池，除非在链式调用中指定了不同的<code>Executor</code>。</p></li><li><p><code>exceptionally</code> 和 <code>handle</code> 方法用于处理异常情况，它们同样遵循上述规则，使用前一阶段的线程池。</p></li></ul></li><li><p><strong>特殊方法</strong>：</p><ul><li><code>complete</code>, <code>completeExceptionally</code>, <code>cancel</code> 这些方法用于手动完成、异常完成或取消<code>CompletableFuture</code>，它们通常由主线程或其他控制流直接调用，而不是在某个特定线程池中执行。</li></ul></li><li><p><strong>组合与转换</strong>：</p><ul><li>在进行多个<code>CompletableFuture</code>的组合操作时（如<code>allOf</code>, <code>anyOf</code>），这些操作本身不直接关联到线程池，它们更多是逻辑上的组合，实际执行还是依赖于构成这些组合的各个<code>CompletableFuture</code>所使用的线程池。</li></ul></li></ol><p>当在自定义线程池中执行的任务里进一步调用<code>thenRunAsync</code>等方法，如果没有特别指定<code>Executor</code>，那么这些方法确实会默认使用<code>ForkJoinPool.commonPool()</code>。这是因为这些<code>then...Async</code>方法自身没有继承前序阶段的<code>Executor</code>设置，除非显式地为它们提供了线程池。</p><p>例如，如果你有如下代码结构：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Executor</span> customExecutor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>someSupplier<span class="token punctuation">,</span> customExecutor<span class="token punctuation">)</span>
                 <span class="token punctuation">.</span><span class="token function">thenRunAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span><span class="token comment">/* 这里默认使用ForkJoinPool.commonPool() */</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，尽管初始的<code>supplyAsync</code>使用了自定义的<code>customExecutor</code>，但接下来的<code>thenRunAsync</code>没有再次指定<code>Executor</code>，因此它会退回到使用默认的<code>ForkJoinPool.commonPool()</code>。</p><p>为了避免这种情况，确保链式调用中每个需要特定线程池的<code>then...Async</code>方法都明确指定了相同的自定义<code>Executor</code>，例如：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Executor</span> customExecutor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>someSupplier<span class="token punctuation">,</span> customExecutor<span class="token punctuation">)</span>
                 <span class="token punctuation">.</span><span class="token function">thenRunAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span><span class="token comment">/* 这里也使用自定义线程池 */</span><span class="token punctuation">}</span><span class="token punctuation">,</span> customExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，整个异步任务链都会在你期望的线程池中执行。</p></div><h3 id="常用方法-2" tabindex="-1"><a class="header-anchor" href="#常用方法-2"><span>常用方法</span></a></h3><p><strong>组合与转换</strong></p><ol><li><p><strong><code>thenApply(Function&lt;? super T,? extends U&gt; fn)</code></strong></p><ul><li>当前阶段完成后，将结果传递给fn函数处理，并返回一个新的CompletableFuture，用于获取fn处理后的结果。</li></ul></li><li><p><strong><code>thenAccept(Consumer&lt;? super T&gt; action)</code></strong></p><ul><li>当前阶段完成后，执行给定的action消费上一阶段的结果，无返回值。</li></ul></li><li><p><strong><code>thenCompose(Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; fn)</code></strong></p><ul><li>当前阶段完成后，将结果传递给fn函数，fn函数应该返回一个新的CompletableFuture，然后新阶段的结果就是这个CompletableFuture的结果。</li></ul></li><li><p><strong><code>thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</code></strong></p><ul><li>当当前和另一个CompletionStage都完成后，将两个结果传递给fn函数处理，并返回一个新的CompletableFuture。</li></ul></li><li><p><strong>whenComplete</strong> ：用于注册一个回调函数，该函数会在 CompletableFuture 的异步操作完成（不论成功还是因为异常而完成）时执行</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 使用whenComplete，无论结果如何都会执行</span>
future<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> throwable<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>throwable <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;计算结果: &quot;</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发生了异常: &quot;</span> <span class="token operator">+</span> throwable<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// executor.shutdown(); // 确保执行器在完成时关闭</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 注意当回调函数执行时，它不会改变原始 CompletableFuture 的完成状态或结果</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p><strong>异常处理</strong></p><ol><li><p><strong><code>exceptionally(Function&lt;Throwable,? extends T&gt; fn)</code></strong></p><ul><li>如果当前阶段出现异常，则使用fn函数处理异常，并返回一个新的CompletableFuture用于获取处理后的结果。</li></ul></li><li><p><strong><code>handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</code></strong></p><ul><li>无论当前阶段是否成功完成，都会执行fn函数。如果成功，第一个参数是结果，第二个参数是null；如果失败，第一个参数是null，第二个参数是异常。</li></ul></li></ol><p><strong>同步等待</strong></p><ol><li><p><strong><code>join()</code></strong></p><ul><li>阻塞当前线程，直到CompletableFuture完成，获取结果或抛出异常。</li></ul></li><li><p><strong><code>get()</code></strong></p><ul><li>类似于join()，但可以设置超时时间，通过get(long timeout, TimeUnit unit)方法。</li></ul></li></ol><p><strong>其他方法</strong></p><ul><li><p><strong><code>complete(T result)</code></strong> 和 <strong><code>completeExceptionally(Throwable ex)</code></strong></p><ul><li>手动完成 CompletableFuture，分别用于设置成功结果或异常。</li></ul></li><li><p><strong><code>isDone()</code></strong> 和 <strong><code>isCancelled()</code></strong></p><ul><li>判断 CompletableFuture 是否已完成或已被取消。</li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">与其他并发工具的比较</p><ul><li><p><strong>与Future的关系</strong>：<code>CompletableFuture</code> 是 <code>Future</code> 的扩展，增加了链式调用、组合操作等功能，而 <code>Future</code> 主要用于获取异步计算的结果，功能较为单一。</p></li><li><p><strong>与CountDownLatch相似之处</strong>：两者都可以用来等待一个或多个任务的完成，但 <code>CompletableFuture</code> 更加灵活，提供了更多的控制流操作，而 <code>CountDownLatch</code> 主要用于简单地等待计数归零，以触发后续操作。</p></li><li><p><strong>与Promise类似</strong>：在JavaScript中，<code>Promise</code> 是一种处理异步操作的模式，它与 <code>CompletableFuture</code> 在设计理念上非常相似，都支持链式调用、错误处理等机制，但它们分别属于Java和JavaScript的生态。</p></li></ul></div><p><code>CompletableFuture</code> 结合了多种并发工具的优点，提供了高度灵活的异步编程模型，适合构建复杂的数据流处理和异步任务链。</p><h3 id="使用场景及示例-2" tabindex="-1"><a class="header-anchor" href="#使用场景及示例-2"><span>使用场景及示例</span></a></h3><ol><li><p><strong>异步处理</strong>：当一个操作很耗时，如数据库查询、网络请求等，可以使用 <code>CompletableFuture</code> 将其异步执行，提高整体响应速度。</p></li><li><p><strong>任务链</strong>：通过 <code>thenApply</code>, <code>thenCompose</code> 等方法，可以轻松构建任务间的依赖关系，实现任务的链式调用。</p></li><li><p><strong>并行处理与合并</strong>：利用 <code>allOf</code> 和 <code>anyOf</code> 方法，可以并行执行多个任务，前者在所有任务都完成时获取结果，后者在任何一个任务完成时获取结果。</p></li><li><p><strong>错误处理</strong>：通过 <code>exceptionally</code> 或 <code>handle</code> 方法，可以优雅地处理异步操作中可能出现的异常。</p></li></ol><p>假设我们有两个异步任务，一个是获取用户信息，另一个是获取用户订单信息，我们可以这样使用 <code>CompletableFuture</code>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CompletableFutureExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserInfo</span><span class="token punctuation">&gt;</span></span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token class-name">String</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 模拟从数据库获取用户信息</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserInfo</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> <span class="token string">&quot;John Doe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Order</span><span class="token punctuation">&gt;</span></span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token class-name">String</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 模拟从数据库获取订单信息</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> <span class="token string">&quot;Books&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> userId <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> orderId <span class="token operator">=</span> <span class="token string">&quot;456&quot;</span><span class="token punctuation">;</span>

        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> combinedFuture <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>
                <span class="token function">getUserInfo</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>userInfo <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;User Info: &quot;</span> <span class="token operator">+</span> userInfo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token function">getOrder</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>order <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Order: &quot;</span> <span class="token operator">+</span> order<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

        combinedFuture<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保所有任务完成</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>传统顺序执行与CompletableFuture执行效率的比较示例：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CompletableFutureMallDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NetMall</span><span class="token punctuation">&gt;</span></span> <span class="token constant">NET_MALLS</span> <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NetMall</span><span class="token punctuation">(</span><span class="token string">&quot;jd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">NetMall</span><span class="token punctuation">(</span><span class="token string">&quot;taobao&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">NetMall</span><span class="token punctuation">(</span><span class="token string">&quot;dangdang&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * Sequentially fetches prices from each online mall.
     * <span class="token keyword">@param</span> <span class="token parameter">malls</span> List of online malls
     * <span class="token keyword">@param</span> <span class="token parameter">productName</span> Product name to fetch price for
     * <span class="token keyword">@return</span> List of formatted price information
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">sequentialPriceFetch</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NetMall</span><span class="token punctuation">&gt;</span></span> malls<span class="token punctuation">,</span> <span class="token class-name">String</span> productName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> malls<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>mall <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;《%s》in %s price is %.2f&quot;</span><span class="token punctuation">,</span> productName<span class="token punctuation">,</span> mall<span class="token punctuation">.</span><span class="token function">getNetMallName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mall<span class="token punctuation">.</span><span class="token function">calcPrice</span><span class="token punctuation">(</span>productName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * Fetches prices concurrently using CompletableFuture for each online mall.
     * This method improves performance by executing queries in parallel.
     * <span class="token keyword">@param</span> <span class="token parameter">malls</span> List of online malls
     * <span class="token keyword">@param</span> <span class="token parameter">productName</span> Product name to fetch price for
     * <span class="token keyword">@return</span> List of formatted price information after all futures complete
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">concurrentPriceFetch</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NetMall</span><span class="token punctuation">&gt;</span></span> malls<span class="token punctuation">,</span> <span class="token class-name">String</span> productName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> malls<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>mall <span class="token operator">-&gt;</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> 
                        <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;《%s》in %s price is %.2f&quot;</span><span class="token punctuation">,</span> productName<span class="token punctuation">,</span> mall<span class="token punctuation">.</span><span class="token function">getNetMallName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mall<span class="token punctuation">.</span><span class="token function">calcPrice</span><span class="token punctuation">(</span>productName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">CompletableFuture</span><span class="token operator">::</span><span class="token function">join</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> startTimeSequential <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pricesSequential <span class="token operator">=</span> <span class="token function">sequentialPriceFetch</span><span class="token punctuation">(</span><span class="token constant">NET_MALLS</span><span class="token punctuation">,</span> <span class="token string">&quot;masql&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printPrices</span><span class="token punctuation">(</span>pricesSequential<span class="token punctuation">,</span> startTimeSequential<span class="token punctuation">,</span> <span class="token string">&quot;Sequential&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">long</span> startTimeConcurrent <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pricesConcurrent <span class="token operator">=</span> <span class="token function">concurrentPriceFetch</span><span class="token punctuation">(</span><span class="token constant">NET_MALLS</span><span class="token punctuation">,</span> <span class="token string">&quot;mysql&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printPrices</span><span class="token punctuation">(</span>pricesConcurrent<span class="token punctuation">,</span> startTimeConcurrent<span class="token punctuation">,</span> <span class="token string">&quot;Concurrent&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printPrices</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> prices<span class="token punctuation">,</span> <span class="token keyword">long</span> startTime<span class="token punctuation">,</span> <span class="token class-name">String</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> priceInfo <span class="token operator">:</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>priceInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;------costTime: %d 毫秒 for %s query\\n&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token annotation punctuation">@NoArgsConstructor</span>
<span class="token annotation punctuation">@Data</span>
<span class="token keyword">class</span> <span class="token class-name">NetMall</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> netMallName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calcPrice</span><span class="token punctuation">(</span><span class="token class-name">String</span> productName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simulate network delay or computation time</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Properly handle interrupted exception</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> productName<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Random price calculation</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在 <code>concurrentPriceFetch</code> 方法中，通过 <code>CompletableFuture.supplyAsync</code> 将每个在线商城的价格查询操作包装成异步任务，充分利用多核CPU资源，提高查询效率。</li><li>使用 <code>map</code> 和 <code>join</code> 方法将 <code>CompletableFuture&lt;String&gt;</code> 转换和收集为最终价格信息列表，确保所有异步操作完成后再继续执行后续逻辑。</li></ul><h2 id="threadlocal" tabindex="-1"><a class="header-anchor" href="#threadlocal"><span>ThreadLocal</span></a></h2><p>ThreadLocal，顾名思义，为线程本地变量。其核心在于为每个线程创建一个单独的变量副本，即使多个线程访问的是同一个ThreadLocal实例，它们看到的也是各自线程内部的独立副本，从而实现了线程间数据的隔离。ThreadLocal的工作原理主要依赖于其内部类<code>ThreadLocalMap</code>，这是一个定制化的哈希映射，键是ThreadLocal实例本身，值则是线程本地存储的变量副本。</p><p>每个线程的<code>Thread</code>类中都有一个名为<code>threadLocals</code>的成员变量，类型为<code>ThreadLocal.ThreadLocalMap</code>，用来存储该线程对应的ThreadLocal变量副本。当线程首次调用ThreadLocal的<code>set()</code>方法设置值时，如果该线程的<code>ThreadLocalMap</code>尚未初始化，则会创建一个新的<code>ThreadLocalMap</code>实例，并将值设置进去。之后，每次调用<code>get()</code>方法时，都会从当前线程的<code>ThreadLocalMap</code>中取出对应的值。</p><div class="hint-container info"><p class="hint-container-title">使用场景</p><ol><li><strong>数据库连接或Session管理</strong>：在Web应用中，为每个请求线程绑定一个数据库连接或用户Session，确保事务处理的隔离性。</li><li><strong>线程上下文信息传递</strong>：如在日志记录中，每个线程记录自己的日志信息，避免了日志信息交错。</li><li><strong>避免参数传递的复杂性</strong>：在方法调用链路长的情况下，避免通过参数传递某些不变的上下文信息。</li><li><strong>缓存线程相关的对象</strong>：例如<code>SimpleDateFormat</code>等非线程安全类的实例，每个线程分配一个，避免同步开销。</li></ol></div><p><strong>使用代码示例</strong>:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 定义ThreadLocal变量</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DateFormatter</span><span class="token punctuation">&gt;</span></span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DateFormatter</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">DateFormatter</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DateFormatter</span><span class="token punctuation">(</span><span class="token string">&quot;yyyy-MM-dd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processDate</span><span class="token punctuation">(</span><span class="token class-name">String</span> dateStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">DateFormatter</span> formatterInstance <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前线程的DateFormatter实例</span>
    <span class="token class-name">Date</span> date <span class="token operator">=</span> formatterInstance<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>dateStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 注意清理，防止内存泄漏</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    formatter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移除当前线程的ThreadLocal变量</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">注意事项</p><ul><li><strong>内存泄漏</strong>：如果线程长时间存活且未调用<code>remove()</code>方法，可能导致ThreadLocalMap中的Entry引用不被垃圾回收，引发内存泄漏。</li><li><strong>非线程安全</strong>：虽然ThreadLocal可以避免多线程间的直接数据竞争，但其内部存储的对象本身仍需考虑线程安全问题。</li><li><strong>使用范围</strong>：适用于线程间不需要共享数据，且数据生命周期与线程相同的场景。</li></ul><p>ThreadLocal是一种强大且灵活的工具，用于解决多线程环境下数据隔离和共享的问题。但使用时需谨慎管理资源，以防止潜在的内存泄露问题。</p></div>`,95),o=[p];function c(l,i){return s(),a("div",null,o)}const k=n(e,[["render",c],["__file","tool.html.vue"]]),d=JSON.parse('{"path":"/java/syntax/thread/tool.html","title":"并发工具类","lang":"en-US","frontmatter":{"order":20,"title":"并发工具类","description":"AQS抽象队列同步器 AQS（AbstractQueuedSynchronizer，抽象队列同步器）是Java并发包（java.util.concurrent.locks）中的一个核心组件，由Doug Lea设计，旨在为实现锁和其他同步组件（如信号量、屏障等）提供基础框架。AQS简化了自定义同步组件的开发过程，通过封装复杂的同步逻辑，如线程的阻塞、唤醒...","head":[["meta",{"property":"og:url","content":"https://x.app/notebook/java/syntax/thread/tool.html"}],["meta",{"property":"og:site_name","content":"Notebook"}],["meta",{"property":"og:title","content":"并发工具类"}],["meta",{"property":"og:description","content":"AQS抽象队列同步器 AQS（AbstractQueuedSynchronizer，抽象队列同步器）是Java并发包（java.util.concurrent.locks）中的一个核心组件，由Doug Lea设计，旨在为实现锁和其他同步组件（如信号量、屏障等）提供基础框架。AQS简化了自定义同步组件的开发过程，通过封装复杂的同步逻辑，如线程的阻塞、唤醒..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-09T16:14:20.000Z"}],["meta",{"property":"article:author","content":"Mr.Topple"}],["meta",{"property":"article:modified_time","content":"2024-06-09T16:14:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发工具类\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-09T16:14:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Topple\\",\\"url\\":\\"https://www.baidu.com\\"}]}"]]},"headers":[{"level":2,"title":"AQS抽象队列同步器","slug":"aqs抽象队列同步器","link":"#aqs抽象队列同步器","children":[]},{"level":2,"title":"Semaphore","slug":"semaphore","link":"#semaphore","children":[{"level":3,"title":"构造函数","slug":"构造函数","link":"#构造函数","children":[]},{"level":3,"title":"常用方法","slug":"常用方法","link":"#常用方法","children":[]},{"level":3,"title":"使用场景及示例","slug":"使用场景及示例","link":"#使用场景及示例","children":[]},{"level":3,"title":"底层实现原理","slug":"底层实现原理","link":"#底层实现原理","children":[]}]},{"level":2,"title":"CyclicBarrier","slug":"cyclicbarrier","link":"#cyclicbarrier","children":[{"level":3,"title":"构造函数","slug":"构造函数-1","link":"#构造函数-1","children":[]},{"level":3,"title":"常用方法","slug":"常用方法-1","link":"#常用方法-1","children":[]},{"level":3,"title":"使用场景及示例","slug":"使用场景及示例-1","link":"#使用场景及示例-1","children":[]},{"level":3,"title":"底层实现原理","slug":"底层实现原理-1","link":"#底层实现原理-1","children":[]}]},{"level":2,"title":"CountDownLatch","slug":"countdownlatch","link":"#countdownlatch","children":[]},{"level":2,"title":"CompletableFuture","slug":"completablefuture","link":"#completablefuture","children":[{"level":3,"title":"特性及原理","slug":"特性及原理","link":"#特性及原理","children":[]},{"level":3,"title":"创建方式","slug":"创建方式","link":"#创建方式","children":[]},{"level":3,"title":"常用方法","slug":"常用方法-2","link":"#常用方法-2","children":[]},{"level":3,"title":"使用场景及示例","slug":"使用场景及示例-2","link":"#使用场景及示例-2","children":[]}]},{"level":2,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[]}],"git":{"createdTime":1717949660000,"updatedTime":1717949660000,"contributors":[{"name":"Neil","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":28.03,"words":8408},"filePathRelative":"java/syntax/thread/tool.md","localizedDate":"June 9, 2024","autoDesc":true}');export{k as comp,d as data};
