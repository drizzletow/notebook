import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as l,c as p,b as a,d as n,a as s,e as o}from"./app-C9pIHXR3.js";const r="/notebook/assets/image-20220215135414096-BEaE3iTy.png",c="/notebook/assets/image-20220207230852752-NVSBTNCg.png",d="/notebook/assets/image-20220215142240397-BG9H0Alm.png",u="/notebook/assets/image-20220216080917450-DUwWiPBE.png",g="/notebook/assets/image-20220217083301260-Dn3la0v1.png",m="/notebook/assets/image-20220216221403691-CYC7cF75.png",v="/notebook/assets/image-20220216221349177-BS8-tHSk.png",h="/notebook/assets/image-20220216231858327-BmoFxngl.png",k="/notebook/assets/image-20220216231533915-BB6qPvnW.png",J="/notebook/assets/image-20220217091955292-BgfabL7x.png",b={},M=a("h1",{id:"jvm内存管理",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#jvm内存管理"},[a("span",null,"JVM内存管理")])],-1),f={href:"https://docs.oracle.com/javase/specs/",target:"_blank",rel:"noopener noreferrer"},_={href:"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html",target:"_blank",rel:"noopener noreferrer"},S={href:"https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf",target:"_blank",rel:"noopener noreferrer"},j=a("h2",{id:"一-jvm简介",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#一-jvm简介"},[a("span",null,"一 JVM简介")])],-1),y={href:"https://docs.oracle.com/javase/specs/index.html",target:"_blank",rel:"noopener noreferrer"},x=o('<p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><p>关于jdk、jre和jvm三个基本概念的中英文及解释：</p><ul><li><p><strong>JDK (Java Development Kits)</strong> -- Java 开发工具集</p><p>JDK 是整个 JAVA 的核心，包括了 Java 运行环 境（Java Runtime Environment），一堆 Java 工具（javac/java/jdb 等）和 Java 基的类库（即 Java API 包括 rt.jar），它不提供具体的开发软件，它提供的是无论你用何种开发软件写 Java 程序都必须用到的类库和 Java 语言规范。</p></li><li><p><strong>JRE (Java Runtime Environment)</strong> --Java 运行时环境</p></li><li><p><strong>JVM （Java Virtual Machine）</strong>-- Java虚拟机</p><p>JVM 可以理解成一个可运行 Java 字节码的虚拟计算机系统， 它有一个解释器组件，可以实现 Java 字节码和计算机操作系统之间的通信 ，对于不同的运行平台，有不同 的 JVM，JVM 屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。</p></li></ul><figure><img src="'+r+'" alt="image-20220215135414096" tabindex="0" loading="lazy"><figcaption>image-20220215135414096</figcaption></figure><p>值得注意的是：Java 虚拟机不和包括Java 在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联。<br> 无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行。可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁。</p><h2 id="二-运行时内存" tabindex="-1"><a class="header-anchor" href="#二-运行时内存"><span>二 运行时内存</span></a></h2><figure><img src="'+c+'" alt="image-20220207230852752" tabindex="0" loading="lazy"><figcaption>image-20220207230852752</figcaption></figure><p>注意事项：</p><ul><li><p><strong>方法区（Method Area）<strong>只是一个规范，其实现方式在jdk1.7及之前为</strong>永久代</strong>，jdk1.8则为<strong>元空间（MetaSpace）</strong>，且元空间存在于本地内存（Native Memory）</p></li><li><p>方法区Java8之后的变化</p><ul><li>移除了永久代( PermGen )，替换为元空间(Metaspace )</li><li>永久代中的class metadata(类元信息）转移到了native memory (本地内存，而不是虚拟机)</li><li>永久代中的 <mark>interned Strings(字符串常量池）和 class static variables(类静态变量) 转移到了Java heap</mark></li><li>永久代参数(PermSize MaxPermSize ) -→元空间参数(MetaspaceSize MaxMetaspaceSize )</li></ul></li><li><p>Java8为什么要将永久代替换成Metaspace ?</p><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li><li>永久代会为GC带来不必要的复杂度，并且回收效率偏低。</li></ul></li></ul><p>​ JDK8前后的运行时内存变化（Hotspot）：</p><figure><img src="'+d+'" alt="image-20220215142240397" tabindex="0" loading="lazy"><figcaption>image-20220215142240397</figcaption></figure><h3 id="_1-程序计数器" tabindex="-1"><a class="header-anchor" href="#_1-程序计数器"><span>1. 程序计数器</span></a></h3><p><strong>程序计数器（ Program Counter Register )</strong> : 是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。</p><p>（ 即用于保存JVM中下一条所要执行的指令的地址 ）</p><p>在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p><strong>特点</strong>：</p><ul><li><p>区别于计算机硬件的pc寄存器，两者不略有不同。</p><p>计算机用pc寄存器来存放“伪指令&quot;或地址，而相对于虚拟机，pc寄存器它表现为一块内存，虚拟机的pc寄存器的功能也是存放伪指令，更确切的说存放的是将要执行指令的地址。</p></li><li><p>当虚拟机正在执行的方法是一个本地( native )方法的时候，jvm的pc寄存器存储的值是undefined。</p></li><li><p>程序计数器是线程私有的，它的生命周期与线程相同，每个线程都有一个。</p></li><li><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何QutOfMemoryError情况的区域。</p></li></ul><p>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>线程私有：</p><ul><li><p>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</p></li><li><p>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</p></li></ul><h3 id="_2-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#_2-虚拟机栈"><span>2. 虚拟机栈</span></a></h3><p>Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，即生命周期和线程相同。Java虚拟机栈和线程同的创建，用于存储栈帧每个方法在执行时都会创建一个<strong>栈帧(Stack Frame)</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><figure><img src="'+u+`" alt="image-20220216080917450" tabindex="0" loading="lazy"><figcaption>image-20220216080917450</figcaption></figure><ul><li><p>**局部变量表(Local Variable Table)**是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。</p><ul><li><p>包括8种基本数据类型、对象引用( reference类型）和returnAddress类型（指向一条字节码指令的地址)。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间( Slot )，其余的数据类型只占用1个。</p><p><mark>注：<strong>Slot单位</strong>：局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference 和 returnAddress八种）</mark></p></li><li><p><strong>大小固定</strong>，在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量（如图所示：）</p></li></ul></li><li><p>**操作数栈(Operand Stack)**也称作操作栈，是一个后入先出栈(LIFO)</p><p>随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。</p></li><li><p><strong>动态链接</strong></p><p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(Dynamic Linking)</p></li><li><p><strong>方法返回地址</strong>：存放调用该方法的PC计数器的值</p><p>一个方法的结束，有两种方式∶正常地执行完成，出现未处理的异常非正常的退出。无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。</p></li></ul><p>基于寄存器的设计模式：就我们所熟知的x86或arm指令集来说，其对数据的操作都是基于寄存器。例如，要对两个数执行加法操作则需要将这两个数分别送入两个寄存器再执行加法操作，这也符合我们对于编程语言认知，更加易于理解。</p><p>但java是基于栈的设计模式（至少多数JVM实现都是如此，少有基于寄存器设计模式的JVM）：基于栈的设计模式则是将数据存放在栈中，在需要使用的时候将栈顶的数据出栈，并执行相应的操作。</p><p>举例来说，在JVM中 执行 a = b + c 的字节码执行过程中操作数栈以及局部变量表的变化如下图所示。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+g+'" alt="image-20220217083301260" tabindex="0" loading="lazy"><figcaption>image-20220217083301260</figcaption></figure><p>更详细的步骤参照：</p><p>局部变量表中存储着a、b、c 三个局部变量，首先将b和c分别入栈 <img src="https://img2018.cnblogs.com/blog/1742182/201908/1742182-20190817151725697-204304284.png" alt="图1" loading="lazy"></p><p>将栈顶的两个数出栈执行加法操作，并将结果保存至栈顶，之后将栈顶的数出栈赋值给a <img src="https://img2018.cnblogs.com/blog/1742182/201908/1742182-20190817152139902-1817873538.png" alt="图2" loading="lazy"></p><p>问题</p><ul><li>垃圾回收是否涉及栈内存？ <ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？ <ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？ <ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果 <strong>局部变量引用了对象</strong>，并 <strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出，<strong>发生原因</strong> ：</p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（如无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h3 id="_3-本地方法栈" tabindex="-1"><a class="header-anchor" href="#_3-本地方法栈"><span>3. 本地方法栈</span></a></h3><p><strong>本地方法栈( Native Method Stacks）</strong>：与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地(Native）方法服务。一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><p>特点</p><ul><li>本地方法栈加载native的方法, native方法存在的意义当然是填补java代码不方便实现的缺陷而提出的</li><li>虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li><li>是线程私有的，它的生命周期与线程相同，每个线程都有一个。</li><li>在Java虚拟机规范中，对本地方法栈这块区域，与Java虚拟机栈一样，规定了两种类型的异常 <ul><li>StackOverFlowError : 线程请求的栈深度 &gt; 所允许的深度。</li><li>0utOfMemoryError: 本地方法栈扩展时无法申请到足够的内存。</li></ul></li></ul><h3 id="_4-堆-heap" tabindex="-1"><a class="header-anchor" href="#_4-堆-heap"><span>4. 堆(Heap)</span></a></h3><p>Java堆（Java Heap） 是虚拟机所管理的内存中最大的一块。 Java堆是被所 有线程共享 的一块内存区域， 在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例， Java 世界里“几乎”所有的对 象实例都在这里分配内存。</p><p>注：“几乎”是指从实现角度来看， 随着Java语 言的发展， 现在已经能看到些许迹象表明日 后可能出现值类型的支持， 即使只考虑现在， 由于即时编译技术的进步， 尤其是逃逸分析技术的日渐强大， 栈上 分配、 标量替换优化手段已经导致一些微妙的变化悄然发生， 所以说Java对象实例都分配在堆上也渐渐变得不是 那么绝对了。</p><p><strong>堆的分类</strong>：（现在垃圾回收器都使用分代理论,堆空间也分类如下: ）</p><p>在Java7 Hotspot虚拟机中将Java堆内存分为3个部分：</p><ul><li>青年代 Young Generation</li><li>老年代 Old Generation</li><li>永久代 Permanent Generation</li></ul><figure><img src="'+m+'" alt="image-20220216221403691" tabindex="0" loading="lazy"><figcaption>image-20220216221403691</figcaption></figure><p>在Java8以后，方法区的内存不在分配在Java堆上，而是存储于本地内存元空间Metaspace中</p><figure><img src="'+v+'" alt="image-20220216221349177" tabindex="0" loading="lazy"><figcaption>image-20220216221349177</figcaption></figure><ul><li><p><strong>年轻代(Young Gen)</strong>：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。</p><p>年轻代分 成1个 <strong>Eden Space</strong> 和2个 <strong>Suvivor Space</strong>（from 和to）</p></li><li><p><strong>年老代(Tenured Gen)</strong>：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍 然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁。</p></li><li><p><strong>配置新生代和老年代堆结构占比</strong> ：</p><ul><li><p>默认 -XX:NewRatio=2 , 标识新生代占1 , 老年代占2 ,新生代占整个堆的1/3</p><p>修改占比 -XX:NewPatio=4 , 标识新生代占1 , 老年代占4 , 新生代占整个堆的1/5</p></li><li><p>Eden空间和另外两个Survivor空间占比分别为8:1:1 可以通过操作选项 -XX:SurvivorRatio 调整这个空间比例。</p><p>比如 -XX:SurvivorRatio=8</p></li><li><p>堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定</p></li></ul><p>几乎所有的java对象都在Eden区创建, 但80%的对象生命周期都很短,创建出来就会被销毁</p><figure><img src="'+h+'" alt="image-20220216231858327" tabindex="0" loading="lazy"><figcaption>image-20220216231858327</figcaption></figure><p>【注意】：JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域 是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间</p></li></ul><p>堆的特点：</p><p>（1）是Java虚拟机所管理的内存中最大的一块。</p><p>（2）堆是jvm所有线程共享的。 堆中也包含私有的线程缓冲区 Thread Local Allocation Buffer (TLAB)</p><p>（3）在虚拟机启动的时候创建。</p><p>（4）唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。</p><p>（5）Java堆是垃圾收集器管理的主要区域</p><p>（6）因此很多时候java堆也被称为“GC堆”（Garbage Collected Heap）。</p><p>​ 从内存回收的角度来看，由于现在收集器 基本都采用分代收集算法，所以Java堆还可以细分为：</p><p>​ 新生代和老年代；新生代又可以分为：Eden 空间、From Survivor空间、To Survivor空间。</p><p>（7）java堆是计算机物理存储上不连续的、逻辑上是连续的，也是大小可调节的（通过-Xms和-Xmx控制）。</p><p>（8）方法结束后,堆中对象不会马上移出仅仅在垃圾回收的时候时候才移除。</p><p>（9）如果在堆中没有内存完成实例的分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常，即：</p><p>​ 堆内存溢出：<strong>java.lang.OutofMemoryError</strong> ： java heap space.</p><p><strong>对象分配过程</strong>：</p><p>1.new的对象先放在伊甸园区。该区域有大小限制</p><p>2.当伊甸园区域填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园预期进行垃圾回收（Minor GC）,将伊 甸园区域中不再被其他对象引用的额对象进行销毁，再加载新的对象放到伊甸园区</p><p>3.然后将伊甸园区中的剩余对象移动到幸存者0区</p><p>4.如果再次触发垃圾回收，此时上次幸存下来的放在幸存者0区的，如果没有回收，就会放到幸存者1区</p><p>5.如果再次经历垃圾回收，此时会重新返回幸存者0区，接着再去幸存者1区。</p><p>6.如果累计次数到达默认的15次，这会进入养老区。 可以通过设置参数，调整阈值 -XX:MaxTenuringThreshold=N</p><p>7.养老区内存不足是,会再次出发GC:Major GC 进行养老区的内存清理</p><p>8.如果养老区执行了Major GC后仍然没有办法进行对象的保存,就会报OOM异常</p><figure><img src="'+k+`" alt="image-20220216231533915" tabindex="0" loading="lazy"><figcaption>image-20220216231533915</figcaption></figure><p><strong>堆GC</strong>： Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：一种是部分收集器（Partial GC）另一类是整堆收集器 （Fu&#39;ll GC）</p><ul><li>部分收集器: 不是完整收集java堆的的收集器,它又分为: <ul><li>新生代收集（Minor GC / Young GC）: 只是新生代的垃圾收集</li><li>老年代收集 （Major GC / Old GC）: 只是老年代的垃圾收集 (CMS GC 单独回收老年代)</li><li>混合收集（Mixed GC）:收集整个新生代及老年代的垃圾收集 (G1 GC会混合回收, region区域回收)</li></ul></li><li>整堆收集（Full GC）: 收集整个java堆和方法区的垃圾收集器</li></ul><p>年轻代GC触发条件:</p><ul><li>年轻代空间不足,就会触发Minor GC， 这里年轻代指的是Eden代满，Survivor不满不会引发GC</li><li>Minor GC会引发 <strong>STW (stop the world)</strong> , 暂停其他用户的线程,等垃圾回收接收,用户的线程才恢复.</li></ul><p>老年代GC (Major GC)触发机制</p><ul><li><p>老年代空间不足时,会尝试触发MinorGC. 如果空间还是不足,则触发Major GC</p></li><li><p>如果Major GC , 内存仍然不足,则报错OOM</p></li><li><p>Major GC的速度比Minor GC慢10倍以上.</p></li></ul><p>FullGC 触发机制:</p><ul><li>调用System.gc() , 系统会执行Full GC （不是立即执行）</li><li>老年代空间不足、或 方法区空间不足</li><li>通过Minor GC进入老年代平均大小大于老年代可用内存</li></ul><h3 id="_5-方法区" tabindex="-1"><a class="header-anchor" href="#_5-方法区"><span>5. 方法区</span></a></h3><p>方法区（Method Area） 与Java堆一样， 是各个线程共享的内存区域， 它用于存储已被虚拟机加载 的类型信息、 常量、 静态变量、 即时编译器编译后的代码缓存等数据。对HotSpot而言，方法区还有一个别名叫做Non-Heap（非堆），的就是 要和堆区分开。</p><p>元空间、永久代是方法区具体的落地实现。方法区看作是一块独立于Java堆的内存空间，它主要是用来存储所加载 的类信息的</p><p><strong>方法区的特点</strong>：</p><ul><li><p>方法区与堆一样是各个线程共享的内存区域</p></li><li><p>方法区在JVM启动的时候就会被创建并且它实例的物理内存空间和 Java堆一样都可以不连续</p></li><li><p>方法区的大小跟堆空间一样 可以选择固定大小或者动态变化</p></li><li><p>方法区的对象决定了系统可以保存多少个类,如果系统定义了太多的类 导致方法区溢出虚拟机同样会跑出 (OOM)异常</p><p>(Java7之前是 PermGen Space (永久带) Java 8之后 是MetaSpace(元空间) )</p></li><li><p>关闭 JVM 就会释放这个区域的内存</p></li></ul><p><strong>永久代（Permanent Generation）</strong>：<br> 永久代是 HotSpot 虚拟机对方法区的具体实现，永久代本身也存在于虚拟机堆中，在 JDK 1.7 中，移除永久代的工作就已经开始了，存储在永久代中的数据转移到了虚拟机堆或者 Native Memory 中</p><ul><li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>jps  <span class="token comment"># 是java提供的一个显示当前所有java进程pid的命令</span>
jinfo <span class="token parameter variable">-flag</span> PermSize 进程号     <span class="token comment">#查看进程的PermSize初始化空间大小</span>
jinfo <span class="token parameter variable">-flag</span> MaxPermSize 进程号  <span class="token comment">#查看PermSize最大空间</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>元空间（Meta Space）</strong>：<br> 从 JDK 1.8 开始，HotSpot 虚拟机完全移除了永久代，改为在 Native Memory 中存放这些数据，新的空间被称为元空间</p><ul><li><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定 默认值依赖于平台。</p><p>windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是 -1，即没有限制。</p></li><li><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟 机一样会抛出异常OutOfMemoryError:Metaspace</p></li><li><p><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为 21MB。</p><p>这就是初始的高水位线，一旦触及这个水位线，FullGC将会被触发并卸载没用的类（即这些类对应的类加载 器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不 足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到FullGC 多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>jps <span class="token comment">#查看进程号</span>
jinfo <span class="token parameter variable">-flag</span> MetaspaceSize 进程号     <span class="token comment">#查看Metaspace 最大分配内存空间</span>
jinfo <span class="token parameter variable">-flag</span> MaxMetaspaceSize 进程号  <span class="token comment">#查看Metaspace最大空间</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><mark>关于永久代和元空间的历史简介：</mark></p><blockquote><p>在JDK 8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。</p><p>本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。</p><p>但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p><p>但现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法（例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。</p><p>当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java MissionControl管理工具，移植到HotSpot虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的**元空间（Meta-space）**来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</p></blockquote><p><strong>运行时常量池（Runtime Constant Pool）</strong>：</p><ul><li><p>常量池：存放编译期间生成的各种字面量与符号引用 —— 字节码文件中，内部包含了常量池</p></li><li><p>运行时常量池：常量池表在运行时的表现形式 —— 方法区中，内部包含了运行时常量池</p></li></ul><p>编译后的字节码文件中包含了类型信息、域信息、方法信息等。通过ClassLoader将<code>字节码文件的常量池</code> 中的信息加 载到内存中，存储在了 <code>方法区的运行时常量池</code> 中.</p><p>具体理解为字节码中的常量池 Constant pool 只是文件信息，它想要执行就必须加载到内存中。而Java程序是靠 JVM，更具体的来说是JVM的执行引擎来解释执行的。执行引擎在运行时常量池中取数据，被加载的字节码常量池 中的信息是放到了方法区的运行时常量池中。 它们不是一个概念，存放的位置是不同的。一个在字节码文件中，一个在方法区中。</p><p><strong>串池（String Table）</strong>：<br> 为避免字符串被重复创建，JVM 引入了串池的概念，当一个字符串变成字符串对象时，该字符串会在已经被创建好的串池中查找是否有同名的字符串，如果有，就将已存在的字符串的地址赋给该字符串对象，如果没有就将该字符串放入串池中，从而降低相同字符串变量对内存的消耗</p><ul><li><p>串池的本质是一个 Hash Table，字符串是它的 KEY，每当有字符串变成字符串变量时，就会检查串池中是否存在和该字符串同名的 KEY</p></li><li><p>String Table 不能扩容，在 JDK 1.6 中存在于常量池中，在 1.8 时存在于堆中</p></li></ul><p><strong>String Table特性</strong>：</p><ul><li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p></li><li><p>字符串变量拼接的原理 —— StringBuilder（1.8）</p><p>jdk1.8之后字符串拼接底层就是创建了一个StringBuilder，然后调用append方法，最后调用toString转化成String</p></li><li><p>字符串常量拼接的原理 —— 编译器优化</p></li></ul><p><strong>jdk1.8和jdk1.6中intern()方法的运用</strong>：</p><ul><li><strong>1.8</strong> 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则**将该字符串的引用放入串池 **</li><li><strong>1.6</strong> 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会<strong>把此对象复制一份，放入串池</strong></li></ul><h3 id="_6-直接内存" tabindex="-1"><a class="header-anchor" href="#_6-直接内存"><span>6. 直接内存</span></a></h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现</p><blockquote><p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制</p><p>一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p></blockquote><p>通过使用堆外内存，可以带来以下好处：</p><ol><li>改善堆过大时垃圾回收效率，减少停顿。Full GC时会扫描堆内存，回收效率和堆大小成正比。Native的内 存，由OS负责管理和回收</li><li>减少内存在Native堆和JVM堆拷贝过程，避免拷贝损耗，降低内存使用。</li><li>可突破 JVM内存大小限制。</li></ol><h2 id="三-内存溢出" tabindex="-1"><a class="header-anchor" href="#三-内存溢出"><span>三 内存溢出</span></a></h2><h3 id="_1-jvm堆溢出" tabindex="-1"><a class="header-anchor" href="#_1-jvm堆溢出"><span>1. Jvm堆溢出</span></a></h3><p>当对象所占空间超过最大堆容量时，就会产生 <code>OutOfMemoryError</code> 的异常</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * @Classname HeapOOM
 * @Description 堆溢出演示，设置最大堆最小堆：-Xms20m -Xmx20m
 * @CreateTime 2022/2/17 9:13
 * @CreatedBy itdrizzle
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOM</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+J+'" alt="image-20220217091955292" tabindex="0" loading="lazy"><figcaption>image-20220217091955292</figcaption></figure><p>产生 <code>OutOfMemoryError</code> 异常的常见原因：</p><ul><li>内存中加载的数据过多，如一次从数据库中取出过多数据；</li><li>集合对对象引用过多且使用完后没有清空；</li><li>代码中存在死循环或循环产生过多重复对象；</li><li>堆内存分配不合理</li></ul><h3 id="_2-jvm栈溢出" tabindex="-1"><a class="header-anchor" href="#_2-jvm栈溢出"><span>2. Jvm栈溢出</span></a></h3><h3 id="_3-方法区溢出" tabindex="-1"><a class="header-anchor" href="#_3-方法区溢出"><span>3. 方法区溢出</span></a></h3><h3 id="_4-直接内存溢出" tabindex="-1"><a class="header-anchor" href="#_4-直接内存溢出"><span>4. 直接内存溢出</span></a></h3>',121);function C(G,V){const e=i("ExternalLinkIcon");return l(),p("div",null,[M,a("p",null,[a("a",f,[n("Java SE Specifications"),s(e)])]),a("p",null,[n("HTML："),a("a",_,[n("The Java® Virtual Machine Specification"),s(e)])]),a("p",null,[n("PDF："),a("a",S,[n("https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf"),s(e)])]),j,a("p",null,[n("Oracle所给的相关规范："),a("a",y,[n("https://docs.oracle.com/javase/specs/index.html"),s(e)])]),x])}const z=t(b,[["render",C],["__file","Jvm内存管理.html.vue"]]),P=JSON.parse('{"path":"/java/syntax/jvm/Jvm%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"JVM内存管理","lang":"en-US","frontmatter":{"order":15,"description":"JVM内存管理 Java SE Specifications HTML：The Java® Virtual Machine Specification PDF：https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf 一 JVM简介 Oracle所给的相关规范：https://docs.oracle...","head":[["meta",{"property":"og:url","content":"https://x.app/notebook/java/syntax/jvm/Jvm%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Notebook"}],["meta",{"property":"og:title","content":"JVM内存管理"}],["meta",{"property":"og:description","content":"JVM内存管理 Java SE Specifications HTML：The Java® Virtual Machine Specification PDF：https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf 一 JVM简介 Oracle所给的相关规范：https://docs.oracle..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img2018.cnblogs.com/blog/1742182/201908/1742182-20190817151725697-204304284.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-04-15T09:06:58.000Z"}],["meta",{"property":"article:author","content":"Mr.Topple"}],["meta",{"property":"article:modified_time","content":"2024-04-15T09:06:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM内存管理\\",\\"image\\":[\\"https://img2018.cnblogs.com/blog/1742182/201908/1742182-20190817151725697-204304284.png\\",\\"https://img2018.cnblogs.com/blog/1742182/201908/1742182-20190817152139902-1817873538.png\\"],\\"dateModified\\":\\"2024-04-15T09:06:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Topple\\",\\"url\\":\\"https://www.baidu.com\\"}]}"]]},"headers":[{"level":2,"title":"一 JVM简介","slug":"一-jvm简介","link":"#一-jvm简介","children":[]},{"level":2,"title":"二 运行时内存","slug":"二-运行时内存","link":"#二-运行时内存","children":[{"level":3,"title":"1. 程序计数器","slug":"_1-程序计数器","link":"#_1-程序计数器","children":[]},{"level":3,"title":"2. 虚拟机栈","slug":"_2-虚拟机栈","link":"#_2-虚拟机栈","children":[]},{"level":3,"title":"3. 本地方法栈","slug":"_3-本地方法栈","link":"#_3-本地方法栈","children":[]},{"level":3,"title":"4. 堆(Heap)","slug":"_4-堆-heap","link":"#_4-堆-heap","children":[]},{"level":3,"title":"5. 方法区","slug":"_5-方法区","link":"#_5-方法区","children":[]},{"level":3,"title":"6. 直接内存","slug":"_6-直接内存","link":"#_6-直接内存","children":[]}]},{"level":2,"title":"三 内存溢出","slug":"三-内存溢出","link":"#三-内存溢出","children":[{"level":3,"title":"1. Jvm堆溢出","slug":"_1-jvm堆溢出","link":"#_1-jvm堆溢出","children":[]},{"level":3,"title":"2. Jvm栈溢出","slug":"_2-jvm栈溢出","link":"#_2-jvm栈溢出","children":[]},{"level":3,"title":"3. 方法区溢出","slug":"_3-方法区溢出","link":"#_3-方法区溢出","children":[]},{"level":3,"title":"4. 直接内存溢出","slug":"_4-直接内存溢出","link":"#_4-直接内存溢出","children":[]}]}],"git":{"createdTime":1713172018000,"updatedTime":1713172018000,"contributors":[{"name":"Neil","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":24.42,"words":7326},"filePathRelative":"java/syntax/jvm/Jvm内存管理.md","localizedDate":"April 15, 2024","autoDesc":true}');export{z as comp,P as data};
